<!DOCTYPE html>

<head>
    <script type="text/javascript" src="crafty-min.js"></script>
    <!--src="http://cdn.craftycomponents.com/crafty-release.js"></script>-->
</head>
<body>

<script type="text/javascript">
var MIN_CARD = 1;
var MAX_CARD = 13;
var MIN_DUPLICATE_SIZE = 2;
var MIN_STRAIGHT_SIZE = 3;

Crafty.scene("menu", function() {
   var count=90;

   var timeText = Crafty.e("2D, DOM, Text").attr({
    w : 2170,
    h : 400,
    x : 370,
    y : 450
}).text("time remaining: " + count).textFont({
    size : '40px'   
});

   var counter=setInterval(timer, 1000); //1000 will  run it every 1 second


   function timer()
   {
     count=count-1;
     if (count < 0)
     {
        clearInterval(counter);
        return;
     }
     var min =Math.floor(count/60);
     var sec =  count%60
     if(sec<10){
        timeText.text("time remaining: " + min + ": " + "0" + sec );
     }
     else{
        timeText.text("time remaining: " + min + ": " + sec );
     }

}

timer();
   var titleText = Crafty.e("2D, DOM, Text").attr({
    w : 2170,
    h : 400,
    x : 435,
    y : 0
}).text("CardBlocks").textFont({
    size : '40px'
});
});

var Game = {
map_grid: {
    width:  13,
    height: 5,
    player_width: 6,
    tile: {
        width:  80,
        height: 80
    },
    contents: [[]],
},
player1pos: 0,
player2pos: 0,
player1card: null,
player2card: null,
player1points: 0,
player2points: 0,

width: function() {
    return this.map_grid.width * this.map_grid.tile.width;
},

height: function() {
    return this.map_grid.height * this.map_grid.tile.height
        + 2*this.map_grid.tile.height;
},



createCard: function() {
    var card = {};
    card.value = Crafty.math.randomInt(MIN_CARD, MAX_CARD);
    card.bg = Crafty.e("Card, 2D, Canvas, Color")
                    .color('rgb(255, 255, 255)')
                    .attr({ x: 0,
                            y: 0,
                            w: Game.map_grid.tile.width - 10,
                            h: Game.map_grid.tile.height - 10 });
    card.text = Crafty.e("2D, DOM, Text")
                      .attr({ x: 10, y:10, })
                      .text(card.value);
                //TODO: figure out how to make the text larger
    card.moveTo = function(x, y) { this.bg.x = x; this.bg.y = y; };
    
    card.bg.attach(card.text);
    card.bg.z = 1;
    card.text.z = 2;
    
    return card;
},
dropCard: function(index) {
    if (index == 0) {
        var column = this.player1pos;
        var row = this.findLowestFreeCell(column);
     
        this.player1card.moveTo(column * this.map_grid.tile.width + 5,
                                 row * this.map_grid.tile.height + 5);
        this.map_grid.contents[column][row] = this.player1card.value;
        return [column, row];
    }
    return [-1, -1];
},
calculatePoints: function(size, type) {
    if (type == 'duplicates') {
        return size;
    } else if (type == 'straights') {
        return size + 1;
    }
},
checkCellForBlocks: function(cellX, cellY) {
    var cellContents = this.map_grid.contents[cellX][cellY];
    var bestBlock = null;
    var type = 'duplicates';

    // Checking X duplicates.
    var bottomX = cellX - 1;
    while (bottomX >= 0 && this.map_grid.contents[bottomX][cellY] == cellContents) {
        bottomX --;
    }
    bottomX ++; // This is the lowest contiguous x that matches cellContents.
    var topX = cellX + 1;
    while (topX < this.map_grid.width && this.map_grid.contents[topX][cellY] == cellContents) {
        topX ++;
    }
    topX --; // This is the top contiguous x that matches cellContents.
    if (topX - bottomX + 1 >= MIN_DUPLICATE_SIZE) {
        var points = this.calculatePoints(topX - bottomX + 1, type);
        if (!bestBlock || points >= bestBlock.points) {
            bestBlock = {bottomX: bottomX, bottomY: cellY, topX: topX, topY: cellY, type: type, points: points};
        }
    }

    // Checking Y duplicates.
    var bottomY = cellY - 1;
    while (bottomY >= 0 && this.map_grid.contents[cellX][bottomY] == cellContents) {
        bottomY --;
    }
    bottomY ++; // This is the lowest contiguous y that matches cellContents.
    var topY = cellY + 1;
    while (topY < this.map_grid.width && this.map_grid.contents[cellX][topY] == cellContents) {
        topY ++;
    }
    topY --; // This is the top contiguous y that matches cellContents.
    if (topY - bottomY + 1 >= MIN_DUPLICATE_SIZE) {
        var points = this.calculatePoints(topY - bottomY + 1, type);
        if (!bestBlock || points >= bestBlock.points) {
            bestBlock = {bottomY: bottomY, bottomX: cellX, topY: topY, topX: cellX, type: type, points: points};
        }
    }

    type = 'straights';

    // Checking X increasing straights.
    var bottomX = cellX - 1;
    while (bottomX >= 0 && this.map_grid.contents[bottomX][cellY] == cellContents - (cellX - bottomX)) {
        bottomX --;
    }
    bottomX ++; // This is the lowest contiguous x that matches cellContents.
    var topX = cellX + 1;
    while (topX < this.map_grid.width && this.map_grid.contents[topX][cellY] == cellContents + (topX - cellX)) {
        topX ++;
    }
    topX --; // This is the top contiguous x that matches cellContents.
    if (topX - bottomX + 1 >= MIN_STRAIGHT_SIZE) {
        var points = this.calculatePoints(topX - bottomX + 1, type);
        if (!bestBlock || points >= bestBlock.points) {
            bestBlock = {bottomX: bottomX, bottomY: cellY, topX: topX, topY: cellY, type: type, points: points};
        }
    }

    // Checking X decreasing straights.
    var bottomX = cellX - 1;
    while (bottomX >= 0 && this.map_grid.contents[bottomX][cellY] == cellContents + (cellX - bottomX)) {
        bottomX --;
    }
    bottomX ++; // This is the lowest contiguous x that matches cellContents.
    var topX = cellX + 1;
    while (topX < this.map_grid.width && this.map_grid.contents[topX][cellY] == cellContents - (topX - cellX)) {
        topX ++;
    }
    topX --; // This is the top contiguous x that matches cellContents.
    if (topX - bottomX + 1 >= MIN_STRAIGHT_SIZE) {
        var points = this.calculatePoints(topX - bottomX + 1, type);
        if (!bestBlock || points >= bestBlock.points) {
            bestBlock = {bottomX: bottomX, bottomY: cellY, topX: topX, topY: cellY, type: type, points: points};
        }
    }

    // Checking Y increasing straights.
    var bottomY = cellY - 1;
    while (bottomY >= 0 && this.map_grid.contents[cellX][bottomY] == cellContents - (cellY - bottomY)) {
        bottomY --;
    }
    bottomY ++; // This is the lowest contiguous y that matches cellContents.
    var topY = cellY + 1;
    while (topY < this.map_grid.width && this.map_grid.contents[cellX][topY] == cellContents + (topY - cellY)) {
        topY ++;
    }
    topY --; // This is the top contiguous y that matches cellContents.
    if (topY - bottomY + 1 >= MIN_STRAIGHT_SIZE) {
        var points = this.calculatePoints(topX - bottomX + 1, type);
        if (!bestBlock || points >= bestBlock.points) {
            bestBlock = {bottomY: bottomY, bottomX: cellX, topY: topY, topX: cellX, type: type, points: points};
        }
    }

    // Checking Y decreasing straights.
    var bottomY = cellY - 1;
    while (bottomY >= 0 && this.map_grid.contents[cellX][bottomY] == cellContents + (cellY - bottomY)) {
        bottomY --;
    }
    bottomY ++; // This is the lowest contiguous y that matches cellContents.
    var topY = cellY + 1;
    while (topY < this.map_grid.width && this.map_grid.contents[cellX][topY] == cellContents - (topY - cellY)) {
        topY ++;
    }
    topY --; // This is the top contiguous y that matches cellContents.
    if (topY - bottomY + 1 >= MIN_STRAIGHT_SIZE) {
        var points = this.calculatePoints(topY - bottomY + 1, type);
        if (!bestBlock || points >= bestBlock.points) {
            bestBlock = {bottomY: bottomY, bottomX: cellX, topY: topY, topX: cellX, type: type, points: points};
        }
    }

    return bestBlock;
},
    
        
findLowestFreeCell: function(column) {
    for (var i=this.map_grid.height-1; i>=0; --i) {
        if (this.map_grid.contents[column][i] == 0) {
            return i;
        }
    }
    return -1;
},

// Initialize and start our game
start: function() {
    // Start crafty and set a background color so that we can see it's working
    Crafty.init(Game.width(), Game.height());
    Crafty.background('green');
    Crafty.scene("menu");

    for (var x = 0; x < Game.map_grid.width; x++) {
        Game.map_grid.contents.push(new Array());
        for (var y = 0; y < Game.map_grid.height; y++) {
            Game.map_grid.contents[x].push(0);

            //color everything in
            if (((x%2==0 && y%2==0) || x%2==1 && y%2==1) && x !=6) {
                Crafty.e('2D, Canvas, Color')
                      .attr({
                          x: x * Game.map_grid.tile.width,
                          y: y * Game.map_grid.tile.height,
                          w: Game.map_grid.tile.width,
                          h: Game.map_grid.tile.height
                       })
                      .color('black');
            } else if(x!=6) {
                // divider
                Crafty.e('2D, Canvas, Color')
                      .attr({
                          x: x * Game.map_grid.tile.width,
                          y: y * Game.map_grid.tile.height,
                          w: Game.map_grid.tile.width,
                          h: Game.map_grid.tile.height
                       })
                      .color('red');
            }
        }
    }
    
    Crafty.e("LeftMarker, 2D, Canvas, Color")
        .color('rgb(0,255,255)')
        .attr({ x: Game.map_grid.tile.width / 3,
                y: Game.map_grid.tile.height / 3 + Game.map_grid.tile.height * 4,
                w: Game.map_grid.tile.width / 3,
                h: Game.map_grid.tile.height / 3 })
        .bind("KeyDown", function(e) {
            var refreshCursorPos = function() {
                this.x = Game.map_grid.tile.width * Game.player1pos + Game.map_grid.tile.width / 3;
                this.y = Game.map_grid.tile.height / 3 
                         + Game.map_grid.tile.height * Game.findLowestFreeCell(Game.player1pos);
            }.bind(this);
            if (e.keyCode == 37) {
                if (Game.player1pos > 0) {
                    --Game.player1pos;
                    refreshCursorPos();
                }
            } else if (e.keyCode == 39) {
                if (Game.player1pos < Game.map_grid.player_width-1) {
                    ++Game.player1pos;
                    refreshCursorPos();
                }
            } else if (Game.player1card != null && (e.keyCode == 32 || e.keyCode == 40)) {
                var dropPos = Game.dropCard(0);

                Game.player1card = Game.createCard();
                Game.player1card.moveTo(Game.map_grid.tile.width, Game.map_grid.tile.height * (Game.map_grid.height+1));
                console.log(Game.checkCellForBlocks(dropPos[0], dropPos[1]));
                refreshCursorPos();
            }

        });
    Crafty.e("RightMarker, 2D, Canvas, Color")
        .color('rgb(127, 0, 255)')
        .attr({x: Game.map_grid.tile.width / 3 + Game.map_grid.tile.width * 7,
               y: Game.map_grid.tile.height / 3 + Game.map_grid.tile.height * 4,
               w: Game.map_grid.tile.width / 3,
               h: Game.map_grid.tile.height / 3 });
    
    Crafty.e("2D, DOM, Text")
          .attr({x: Game.map_grid.tile.width, y:Game.map_grid.tile.height * 6 - 20, w: 100, h: 100 })
          .text('next card:');

    Game.player1card = Game.createCard();
    Game.player1card.moveTo(Game.map_grid.tile.width, Game.map_grid.tile.height * (Game.map_grid.height+1));
}
};
window.addEventListener('load', Game.start);
</script>
</body>
</html>
